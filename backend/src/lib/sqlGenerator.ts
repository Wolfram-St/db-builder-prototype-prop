import knex from 'knex';
import type { DBTable, Relation } from '../types/schema.js'; // Kept .js extension

const pg = knex({
  client: 'pg',
  wrapIdentifier: (value, origImpl) => origImpl(value),
  log: { warn: () => {}, error: () => {}, deprecate: () => {}, debug: () => {} }
});

const ACTION_MAP: Record<string, string> = {
  "cascade": "CASCADE",
  "restrict": "RESTRICT",
  "set-null": "SET NULL",
  "no action": "NO ACTION"
};

export const generateSQL = (tables: DBTable[], relations: Relation[]): string => {
  const sqlStatements: string[] = [];
  const seenNames = new Set<string>();

  // --- PASS 1: CREATE TABLES ---
  tables.forEach(table => {
    const normalizedName = table.name.trim().toLowerCase();
    if (seenNames.has(normalizedName)) return;
    seenNames.add(normalizedName);

    const query = pg.schema.createTable(table.name, (t) => {
      // FIX 1: Added ': any' to 'col' to stop the TS7006 error
      table.columns.forEach((col: any) => {
        const type = col.type.toLowerCase();

        if (col.isPrimary) {
           if (type.includes('int') || type.includes('serial')) {
             t.specificType(col.name, 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
           } else if (type.includes('uuid')) {
             t.uuid(col.name).primary().defaultTo(pg.raw('gen_random_uuid()'));
           } else {
             t.text(col.name).primary();
           }
           return; 
        }

        let columnBuilder;
        if (type.includes('uuid')) columnBuilder = t.uuid(col.name);
        else if (type.includes('int')) columnBuilder = t.integer(col.name);
        else if (type.includes('bool')) columnBuilder = t.boolean(col.name);
        else if (type.includes('time') || type.includes('date')) columnBuilder = t.timestamp(col.name);
        else if (type.includes('json')) columnBuilder = t.jsonb(col.name);
        else if (type.includes('float')) columnBuilder = t.float(col.name);
        else columnBuilder = t.text(col.name);

        if (!col.isNullable) columnBuilder.notNullable();
        if (col.isUnique) columnBuilder.unique();
      });
    }).toQuery();

    sqlStatements.push(query + ";");
  });

  if (relations.length > 0) {
      sqlStatements.push("\n-- Foreign Keys");
  }

  // --- PASS 2: ADD CONSTRAINTS ---
  const processedConstraints = new Set<string>();

  relations.forEach(rel => {
    const childTable = tables.find(t => t.id === rel.to.tableId);
    const parentTable = tables.find(t => t.id === rel.from.tableId);

    if (!childTable || !parentTable) return;

    const expectedName = `${parentTable.name.toLowerCase()}_id`;
    
    // FIX 2: Added ': any' to 'c' to stop the TS7006 error
    const fkCol = childTable.columns.find((c: any) => 
      (c.references && c.references.tableId === parentTable.id) || 
      c.name.toLowerCase() === expectedName
    );

    if (!fkCol) return;

    const constraintKey = `${childTable.name}.${fkCol.name}`;
    if (processedConstraints.has(constraintKey)) return;
    processedConstraints.add(constraintKey);

    const deleteRule = ACTION_MAP[rel.deleteRule || 'cascade'] || 'CASCADE';
    const updateRule = ACTION_MAP[rel.updateRule || 'cascade'] || 'CASCADE';
    
    const constraintName = `fk_${childTable.name}_${fkCol.name}`.substring(0, 63); // PG limit

    const alterQuery = `ALTER TABLE "${childTable.name}" ADD CONSTRAINT "${constraintName}" FOREIGN KEY ("${fkCol.name}") REFERENCES "${parentTable.name}" ("id") ON DELETE ${deleteRule} ON UPDATE ${updateRule};`;
    
    sqlStatements.push(alterQuery);
  });

  return sqlStatements.join('\n');
};