import knex from 'knex';
import type { DBTable, Relation} from '../store/dbStore';

// 1. Initialize Knex for Postgres (Client mode only - no DB connection)
const pg = knex({
  client: 'pg',
  log: { warn: () => {}, error: () => {}, deprecate: () => {}, debug: () => {} }
});

// --- HELPER: Topological Sort ---
// Ensures tables are created in the correct order: Parents -> Children
function getSortedTables(tables: DBTable[], relations: Relation[]): DBTable[] {
  const inDegree = new Map<string, number>();
  const adjList = new Map<string, string[]>();

  // Initialize graph
  tables.forEach(t => {
    inDegree.set(t.id, 0);
    adjList.set(t.id, []);
  });

  // Build Graph from Relations
  // Relation structure in dbStore.ts:
  // from: { tableId, columnId } -> THIS IS THE PARENT (PK side usually)
  // to:   { tableId, columnId } -> THIS IS THE CHILD (FK side usually)
  //
  // WAIT: In your store's `startRelation` logic:
  // "pkA... parentTable = tableA... newRelation.from = parentEndpoint"
  // So 'from' is the PARENT (User) and 'to' is the CHILD (Post).
  // Dependency Direction: CHILD depends on PARENT.
  // Edge: PARENT -> CHILD.
  //
  // For creation order, we need PARENT first.
  // So in Kahn's algorithm:
  // Dependency: Child depends on Parent.
  // Graph Edge for sorting: Parent -> Child
  
  relations.forEach(r => {
    const parentId = r.from.tableId;
    const childId = r.to.tableId;

    if (parentId !== childId) { // Ignore self-references for sorting
        if (adjList.has(parentId)) {
            adjList.get(parentId)?.push(childId);
            inDegree.set(childId, (inDegree.get(childId) || 0) + 1);
        }
    }
  });

  // Kahn's Algorithm
  const queue: string[] = [];
  inDegree.forEach((count, id) => {
    if (count === 0) queue.push(id);
  });

  const sortedIds: string[] = [];
  while (queue.length > 0) {
    const u = queue.shift()!;
    sortedIds.push(u);

    const neighbors = adjList.get(u) || [];
    for (const v of neighbors) {
      inDegree.set(v, (inDegree.get(v) || 0) - 1);
      if (inDegree.get(v) === 0) {
        queue.push(v);
      }
    }
  }

  // Handle Cycles/Disconnected components: Add any tables missed by the sort
  const remaining = tables.filter(t => !sortedIds.includes(t.id));
  
  // Return sorted + remaining
  return [...sortedIds.map(id => tables.find(t => t.id === id)!), ...remaining].filter(Boolean);
}

// --- THE GENERATOR ---
export const generateSQL = (tables: DBTable[], relations: Relation[]): string => {
  const sortedTables = getSortedTables(tables, relations);
  const sqlStatements: string[] = [];

  // Deduplicate tables (Robustness check)
  const seenNames = new Set<string>();

  sortedTables.forEach(table => {
    // 1. Skip if duplicate name
    const normalizedName = table.name.trim().toLowerCase();
    if (seenNames.has(normalizedName)) return;
    seenNames.add(normalizedName);

    // 2. Build Create Table Query
    const query = pg.schema.createTable(table.name, (t) => {
      
      table.columns.forEach(col => {
        let columnBuilder;

        // Map Store Types to SQL Types
        // Your store defaults to "text", usually user types "uuid", "int", etc.
        const type = col.type.toLowerCase();
        
        if (type.includes('uuid')) {
            columnBuilder = t.uuid(col.name);
        } else if (type.includes('int') || type.includes('serial')) {
            columnBuilder = t.integer(col.name);
        } else if (type.includes('bool')) {
            columnBuilder = t.boolean(col.name);
        } else if (type.includes('timestamp')) {
            columnBuilder = t.timestamp(col.name);
        } else {
            // Default/Fallback
            columnBuilder = t.text(col.name);
        }

        // Add Constraints
        if (col.isPrimary) {
          columnBuilder.primary();
          // Smart Defaults based on type
          if (type.includes('uuid')) columnBuilder.defaultTo(pg.raw('gen_random_uuid()'));
          else if (type.includes('int')) columnBuilder.defaultTo(pg.raw('generated by default as identity'));
        } else {
          if (!col.isNullable) columnBuilder.notNullable();
          if (col.isUnique) columnBuilder.unique();
        }
      });

      // 3. Add Foreign Keys (Inline)
      // We look for relations where THIS table is the 'to' (Child) side.
      const incomingRelations = relations.filter(r => r.to.tableId === table.id);
      
      incomingRelations.forEach(rel => {
        const parentTable = tables.find(tbl => tbl.id === rel.from.tableId);
        if (parentTable) {
           // Find the actual FK column in this table
           // In your store, logic adds a column named "{parent_name}_id" or similar
           // We try to match the Relation to a Column via references or naming convention
           
           // Option A: Check if any column explicitly references the parent
           let fkCol = table.columns.find(c => 
               c.references && 
               c.references.tableId === parentTable.id
           );

           // Option B: Fallback to name matching (standard behavior in your store)
           if (!fkCol) {
             const expectedName = `${parentTable.name.toLowerCase()}_id`; // simplistic snake_case
             fkCol = table.columns.find(c => c.name === expectedName);
           }

           if (fkCol) {
             // Create Constraint
             t.foreign(fkCol.name)
              .references(`${parentTable.name}.id`) // Assuming parent PK is 'id'
              .onDelete(rel.deleteRule?.toUpperCase() || 'SET NULL')
              .onUpdate(rel.updateRule?.toUpperCase() || 'CASCADE');
           }
        }
      });

    }).toQuery();

    sqlStatements.push(query + ";");
  });

  return sqlStatements.join('\n\n');
};